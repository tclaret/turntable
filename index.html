<!DOCTYPE html>
<html lang="fr">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Scratching Vinyl </title>

<!-- Tailwind CSS et Tone.js pour l'audio avancé -->
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

<style>
    /* Configuration du fond et de la police */
    body {
        font-family: 'Inter', sans-serif;
        background-color: #1a1a2e; /* Couleur de fond sombre  */
        color: #ffffff;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; 
    }
    
    /* Le conteneur principal de la platine */
    #turntable-container {
        position: relative;
        width: 90vmin;
        height: 90vmin;
        max-width: 900px;
        max-height: 900px;
        background: #333; /* Couleur de base pour le plateau */
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        overflow: hidden;
        /* Centre la platine dans le viewport */
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    /* Styles pour le VINYLE (au centre de la platine) */
    #vinyl-image {
        /* Position absolue au centre du #turntable-container */
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); /* Clé du centrage parfait */
        
        width: 80%;
        height: 80%;
        border-radius: 50%;
        
        /* Utilisation de l'image de vinyl */
        background-image: url('https://tclaret.github.io/turntable/img/DISC.png');
        background-size: cover;
        background-position: center;
        
        border: 1px solid #111;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 0 10px rgba(0, 0, 0, 0.9);
        z-index: 10;
        cursor: grab;
        touch-action: none; 
        transition: none;
    }
    
    /* Le SVG à l'intérieur du vinyle pour l'étiquette centrale (invisible car l'image est utilisée) */
    #vinyl-image svg {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 25%; 
        height: 25%;
        opacity: 0; 
        pointer-events: none;
    }


    /* ---------------------------------------------------- */
    /* STYLES RPM */
    /* ---------------------------------------------------- */
    #rpm-wrapper {
        position: absolute; bottom: 5%; left: 5%; width: auto;
        display: flex; flex-direction: column; align-items: center;     
        gap: 8px; z-index: 50; background: rgba(0,0,0,0.2); 
        padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
        transition: left 0.5s ease-in-out, padding 0.3s ease;
    }
    
    /* Classe pour centrer le RPM en mode Zoom sur desktop */
    .rpm-scratch-centered { left: 15% !important; }

    /* Étiquettes du haut (45 - OFF - 33) */
    .rpm-labels {
        display:flex; justify-content:space-between; width: 90px; font-size: 10px;
        font-family: sans-serif; font-weight: bold; color: #d0d0d0;
        text-shadow: 0 1px 2px black; pointer-events: none;
    }
    .rpm-labels span { width: 25px; text-align: center; }

    /* Contrôles de points au milieu */
    #rpm-controls { display:flex; justify-content:space-between; width: 90px; position: relative; }

    .rpm-choice {
        width: 16px; height: 16px; border-radius: 50%; background: #444; border: 2px solid #222;
        cursor: pointer; box-shadow: inset 0 2px 3px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.2);
        transition: background 0.2s; margin: 0 auto; 
    }
    .rpm-choice:hover { background: #666; }
    .rpm-choice.active { 
        background: #00ff00; 
        box-shadow: 0 0 10px #00ff00, inset 0 2px 3px rgba(0,0,0,0.5);
        border-color: #003300;
    }

    /* Image du bouton en bas */
    #rpm-img {
        width: 30px; height: auto; display: block;
        transform-origin: center center;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        filter: drop-shadow(0 5px 5px rgba(0,0,0,0.7));
    }

    /* ---------------------------------------------------- */
    /* PITCH CONTROL (Bas-Droite) - Élargi */
    /* ---------------------------------------------------- */
    #pitch-wrapper {
        position: absolute; bottom: 5%; right: 5%; 
        width: 180px; /* Élargissement du wrapper */
        background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.1); z-index: 50;
    }
    #pitch-slider {
        -webkit-appearance: none; width: 100%; height: 6px; background: #444;
        border-radius: 3px; outline: none; cursor: pointer;
    }
    #pitch-slider::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none; width: 16px; height: 28px; /* Plus haut pour simuler le levier */
        border-radius: 3px; background: #00bcd4; cursor: pointer;
        box-shadow: 0 0 5px rgba(0, 188, 212, 0.8), inset 0 1px 3px rgba(255,255,255,0.4);
    }

    /* Nouvelle échelle visuelle */
    #pitch-scale {
        position: relative;
        height: 15px;
        margin-top: 5px;
    }
    .pitch-mark {
        position: absolute;
        top: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #aaa;
        font-size: 9px;
        font-weight: bold;
    }
    .pitch-mark::before {
        content: '|';
        display: block;
        line-height: 1;
        font-size: 10px;
        height: 5px;
    }
    .pitch-mark.center {
        color: #00ff00; /* Marqueur central de couleur vive */
    }

    /* Positionnement des marques */
    #mark-neg-10 { left: 0%; transform: translateX(-50%); }
    #mark-neg-05 { left: 25%; transform: translateX(-50%); }
    #mark-zero { left: 50%; transform: translateX(-50%); }
    #mark-pos-05 { left: 75%; transform: translateX(-50%); }
    #mark-pos-10 { left: 100%; transform: translateX(-50%); }
    
    
    /* Boutons de contrôle (Haut) */
    #top-controls {
        position: absolute; top: 2%; left: 50%; transform: translateX(-50%);
        display: flex; gap: 15px; z-index: 60; padding: 10px; border-radius: 12px;
    }
    .control-button {
        padding: 8px 15px; border-radius: 6px; font-size: 14px; font-weight: bold;
        cursor: pointer; transition: all 0.2s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .control-button:hover { transform: translateY(-2px); box-shadow: 0 6px 10px rgba(0,0,0,0.4); }

    /* Le rectangle d'affichage (en haut à droite) */
    #overlay-box {
        position: absolute; top: 5%; right: 5%; width: 150px; height: 60px;
        background-color: rgba(60, 60, 80, 0.7); border-radius: 8px;
        display: flex; flex-direction: column; justify-content: center;
        align-items: center; font-size: 14px; z-index: 20; 
        
        /* Transition pour l'opacité et positionnement initial */
        transition: opacity 0.5s ease-out;
    }

    /* État caché initial */
    .overlay-hidden { opacity: 0; pointer-events: none; }
    
    #overlay-box #status-message { font-size: 10px; color: #999; }

    /* ---------------------------------------------------- */
    /* Styles pour le mode Mobile / Vue Zoom */
    /* ---------------------------------------------------- */
    @media (max-width: 768px) {
        /* Vinyle décalé vers la droite, bord gauche libre pour le pouce (mode scratch par défaut) */
        #vinyl-image { left: 62.5%; width: 100%; height: 100%; }

        /* Centrage du vinyle en mode Vue Centrée sur mobile */
        #vinyl-image.centered-mobile { left: 50%; width: 80%; height: 80%; }

        /* RPM et Pitch légèrement plus petits et plus hauts */
        #rpm-wrapper { bottom: 20px; left: 10px; padding: 8px; transform: scale(0.9); transform-origin: bottom left; }
        #pitch-wrapper { bottom: 20px; right: 10px; padding: 8px; transform: scale(0.9); transform-origin: bottom right; width: 140px; } /* Ajustement pour le mobile */

        /* Les contrôles du haut restent visibles */
        #top-controls { top: 20px; padding: 5px 10px; background: rgba(0,0,0,0.5); border-radius: 8px; }
    }
    
    /* Classe pour le déplacement du vinyle en mode scratch sur desktop */
    .vinyl-scratch-desktop { left: 62.5% !important; width: 100% !important; height: 100% !important; }
    
</style>
</head>
<body>

    <div id="main-container" class="relative">

        <!-- Le conteneur de la platine -->
        <div id="turntable-container">
            
            <!-- Le disque vinyle (au centre, ou décalé en mode zoom/scratch) -->
            <div id="vinyl-image" class="touch-manipulation">
                <!-- Étiquette centrale SVG (Invisible) -->
                <svg viewBox="0 0 100 100" class="w-full h-full p-2">
                    <circle cx="50" cy="50" r="48" fill="#e74c3c"/>
                    <circle cx="50" cy="50" r="10" fill="#222"/>
                    <text x="50" y="50" dominant-baseline="middle" text-anchor="middle" font-size="8" fill="#fff" font-weight="bold">SCRATCH</text>
                </svg>
            </div>
            
            <!-- Contrôles du haut (Direction & Zoom) -->
            <div id="top-controls">
                <!-- Bouton Sens (Normal / Inversé) -->
                <button id="direction-button" class="control-button bg-gray-600 text-white hover:bg-gray-700">Sens: Normal</button>
                
                <!-- Bouton Zoom / Vue Centrée -->
                <button id="zoom-button" class="control-button bg-blue-500 text-white hover:bg-blue-600">Vue Centrée</button>
            </div>


            <!-- Le rectangle d'affichage (en haut à droite) -->
            <div id="overlay-box" class="overlay-hidden">
                <p class="text-xs text-white">Vitesse Actuelle:</p>
                <p id="current-rpm-display" class="text-xl font-bold">STOP</p>
                <span id="status-message">Chargement Audio...</span>
            </div>

            <!-- Contrôle RPM (Bas-Gauche) -->
            <div id="rpm-wrapper">
                <!-- 1. Étiquettes du haut (45 - OFF - 33) -->
                <div class="rpm-labels">
                    <span data-mode="45">45</span>
                    <span data-mode="off">ARRÊT</span>
                    <span data-mode="33">33</span>
                </div>

                <!-- 2. Contrôles de points au milieu -->
                <div id="rpm-controls">
                    <div class="rpm-choice" data-mode="45" title="45 RPM"></div>
                    <div class="rpm-choice active" data-mode="off" title="Arrêt"></div>
                    <!-- Clé '33' utilisée pour la vitesse 33 1/3 RPM -->
                    <div class="rpm-choice" data-mode="33" title="33 1/3 RPM"></div> 
                </div>

                <!-- 3. Image du bouton en bas -->
                <img id="rpm-img" 
                     src="https://tclaret.github.io/turntable/img/ChickenHead.png" 
                     alt="Bouton RPM"
                     style="transform: rotate(0deg);">
            </div>
            
            <!-- Pitch Control (Bas-Droite) -->
            <div id="pitch-wrapper">
                <label for="pitch-slider" class="block text-xs font-semibold mb-1 text-center">PITCH (± 10%)</label>
                
                <!-- Curseur du Pitch -->
                <input type="range" id="pitch-slider" min="-0.1" max="0.1" step="0.001" value="0.0" class="w-full">
                
                <!-- Échelle Visuelle -->
                <div id="pitch-scale">
                    <span class="pitch-mark" id="mark-neg-10">-10</span>
                    <span class="pitch-mark" id="mark-neg-05">-5</span>
                    <span class="pitch-mark center" id="mark-zero">0</span>
                    <span class="pitch-mark" id="mark-pos-05">+5</span>
                    <span class="pitch-mark" id="mark-pos-10">+10</span>
                </div>

                <div id="pitch-value" class="text-center text-xs mt-1">0.00 %</div>
            </div>

        </div>

    </div>

    <script type="module">
        // --- CONFIGURATION ET INITIALISATION ---
        
        // Simuler la configuration Firebase/Auth (essentiel pour l'environnement Canvas)
        const __app_id = "default-app-id";
        const __firebase_config = '{}'; 
        const __initial_auth_token = undefined;
        
        // Configuration des vitesses de lecture de base (facteur pour Tone.js)
        const RPM_RATES = {"45": 1.35, "off": 0, "33": 1.0}; 
        const RPM_ROTATION = {"45": -30, "off": 0, "33": 30}; // Rotation visuelle du bouton
        
        // --- ÉTATS GLOBAUX ---
        let currentMode = "off";
        let pitchFactor = 1.0;
        let directionFactor = 1.0; // 1.0 = Normal, -1.0 = Inversé (détermine le signe de la rate)
        let targetBaseVelocity = 0; // Vitesse de lecture du moteur (RPM seulement)
        
        let isScratchMode = false; // False = Vue Centrée, True = Vue Zoom/Scratch
        
        // --- NOUVELLES VARIABLES POUR LE CONTRÔLE AUDIO MANUEL ---
        let lastTime = performance.now(); // Temps de la dernière frame pour calculer le delta temps (dt)
        let audioTime = 0; // Position de lecture dans le buffer (en secondes)
        let bufferDuration = 0; // Durée totale du morceau
        let currentVelocity = 0; // Vitesse angulaire (rate) instantanée pendant le scratch
        const ANGULAR_MULTIPLIER = 0.015; // Sensibilité angulaire pour le taux de lecture audio (ajusté pour un meilleur scratch)
        const VISUAL_RPM_MULTIPLIER = 50; // Facteur de vitesse visuelle pour la rotation du moteur
        
        // Variables pour le Scratch ANGLULAIRE
        let isScratching = false;
        let lastAngle = 0; // Angle précédent de la touche
        let rotationDegrees = 0; // Rotation visuelle cumulée en degrés
        
        // Variable pour gérer l'affichage de l'overlay
        let overlayTimeoutId = null; 
        
        // --- ÉLÉMENTS DU DOM ---
        const turntableContainer = document.getElementById('turntable-container');
        const vinylImage = document.getElementById('vinyl-image');
        const rpmChoices = document.querySelectorAll('.rpm-choice');
        const rpmImg = document.getElementById('rpm-img');
        const currentRpmDisplay = document.getElementById('current-rpm-display');
        const statusMessage = document.getElementById('status-message');
        const pitchSlider = document.getElementById('pitch-slider');
        const pitchValueDisplay = document.getElementById('pitch-value');
        const directionButton = document.getElementById('direction-button');
        const zoomButton = document.getElementById('zoom-button');
        const rpmWrapper = document.getElementById('rpm-wrapper');
        const overlayBox = document.getElementById('overlay-box');


        // --- LOGIQUE D'AFFICHAGE/MASQUAGE DE L'OVERLAY ---

        const showOverlayBriefly = () => {
            // 1. Annuler tout masquage en cours
            if (overlayTimeoutId) {
                clearTimeout(overlayTimeoutId);
            }
            
            // 2. Afficher l'overlay immédiatement
            overlayBox.classList.remove('overlay-hidden');
            
            // 3. Définir un nouveau timeout pour masquer après 1.5 seconde
            overlayTimeoutId = setTimeout(() => {
                overlayBox.classList.add('overlay-hidden');
            }, 1500); // 1500ms = 1.5 seconde
        };

        // --- CONFIGURATION AUDIO TONE.JS ---
        let player = null;
        let normalBuffer = null; 
        let audioContextStarted = false;
        
        // Fonction pour charger l'audio
        async function loadAudio() {
            statusMessage.textContent = "Chargement de la piste...";
            showOverlayBriefly();

            const audioUrl = "https://tclaret.github.io/turntable/JB_Cold_Sweat.opus";
            
            try {
                // 1. Charger le buffer normal
                normalBuffer = await new Tone.Buffer(audioUrl, 
                    // Succès
                    () => {
                        bufferDuration = normalBuffer.duration; // IMPORTANT: Stocker la durée
                        statusMessage.textContent = "Piste chargée. Prêt à jouer !";
                        showOverlayBriefly();
                        
                        // 2. Créer le lecteur Tone.js (une fois le buffer chargé)
                        try {
                            player = new Tone.Player(normalBuffer).toDestination();
                            player.loop = true;
                            // Taux de lecture fixe à 1.0, car nous gérons le temps manuellement
                            player.playbackRate = 1.0; 
                            player.start(0); 
                            
                            statusMessage.textContent = "Prêt. Cliquez sur 33 ou 45 !";
                            showOverlayBriefly();
                        } catch (e) {
                            console.error("Erreur lors de la création du lecteur Tone.js:", e);
                            statusMessage.textContent = "Erreur (Lecteur Audio).";
                            showOverlayBriefly();
                        }
                    },
                    // Erreur
                    (error) => {
                        console.error("Erreur de chargement audio (CORS/MIME type OPUS):", error);
                        statusMessage.textContent = "Erreur de chargement.";
                        showOverlayBriefly();
                    }
                );
            } catch (error) {
                console.error("Erreur Tone.js:", error);
                statusMessage.textContent = "Erreur critique.";
                showOverlayBriefly();
            }
        }

        // --- GESTION DU MODE RPM & PITCH ---

        // Fonction principale pour définir le mode RPM
        const setRpmMode = (mode) => {
            if (!player || !player.loaded) return;
            if (currentMode === mode && mode !== 'off') return; 

            currentMode = mode;
            
            // 1. Mise à jour des points lumineux
            rpmChoices.forEach(c => c.classList.remove('active'));
            document.querySelector(`.rpm-choice[data-mode='${mode}']`).classList.add('active');

            // 2. Mise à jour de la rotation du bouton (Chicken Head)
            rpmImg.style.transform = `rotate(${RPM_ROTATION[mode]}deg)`;
            
            // 3. Mise à jour de l'état du moteur
            if (mode === 'off') {
                targetBaseVelocity = 0;
                currentRpmDisplay.textContent = 'STOP';
                statusMessage.textContent = "Arrêté, prêt à jouer.";
            } else {
                targetBaseVelocity = RPM_RATES[mode];
                currentRpmDisplay.textContent = mode + ' tours';
                statusMessage.textContent = (directionFactor > 0) ? "En Lecture" : "Lecture Inversée";
            }
            
            showOverlayBriefly();
            // NOTE: L'audio est mis à jour dans la boucle animate(), pas ici.
        };

        // GESTION DU PITCH (Met à jour le facteur, l'audio est géré dans animate)
        pitchSlider.addEventListener('input', () => {
            pitchFactor = 1.0 + parseFloat(pitchSlider.value);
            pitchValueDisplay.textContent = (parseFloat(pitchSlider.value) * 100).toFixed(2) + ' %';
        });

        // GESTION DE LA DIRECTION (NORMAL/INVERSÉ)
        directionButton.addEventListener('click', () => {
            directionFactor *= -1; // Basculer entre 1.0 et -1.0
            
            // Mise à jour de l'interface
            if (directionFactor === 1.0) {
                directionButton.textContent = 'Sens: Normal';
                directionButton.classList.remove('bg-red-700');
                directionButton.classList.add('bg-gray-600');
                if (currentMode !== 'off') statusMessage.textContent = 'En Lecture';
            } else {
                directionButton.textContent = 'Sens: Inversé';
                directionButton.classList.remove('bg-gray-600');
                directionButton.classList.add('bg-red-700');
                if (currentMode !== 'off') statusMessage.textContent = 'Lecture Inversée';
            }
            
            showOverlayBriefly();
        });


        // --- LOGIQUE DE POSITIONNEMENT SCRATCH/ZOOM ---
        
        const isMobile = () => window.innerWidth <= 768;

        const updateScratchModeUI = () => {
            if (isMobile()) {
                if (isScratchMode) {
                    vinylImage.classList.add('centered-mobile');
                    zoomButton.textContent = 'Vue Centrée'; 
                } else {
                    vinylImage.classList.remove('centered-mobile');
                    zoomButton.textContent = 'Zoom'; 
                }
                rpmWrapper.classList.remove('rpm-scratch-centered');
            } else {
                if (isScratchMode) {
                    vinylImage.classList.add('vinyl-scratch-desktop');
                    rpmWrapper.classList.add('rpm-scratch-centered');
                    zoomButton.textContent = 'Vue Centrée';
                } else {
                    vinylImage.classList.remove('vinyl-scratch-desktop');
                    rpmWrapper.classList.remove('rpm-scratch-centered');
                    zoomButton.textContent = 'Zoom';
                }
            }
        };
        
        zoomButton.addEventListener('click', () => {
            isScratchMode = !isScratchMode;
            updateScratchModeUI();
        });
        
        window.addEventListener('resize', updateScratchModeUI);


        // --- LOGIQUE DE SCRATCH (Souris & Touch) ---
        
        // Fonction utilitaire pour obtenir le centre du vinyle (coordonnées d'écran)
        const getVinylCenter = () => {
            const rect = vinylImage.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        };

        // Fonction utilitaire pour obtenir l'angle de la position (x, y) par rapport au centre
        const getAngle = (x, y, centerX, centerY) => {
            const dx = x - centerX;
            const dy = y - centerY;
            // atan2 retourne l'angle en radians (-PI à PI), conversion en degrés
            return Math.atan2(dy, dx) * (180 / Math.PI);
        };
        
        const startScratch = (clientX, clientY) => {
            if (!player || currentMode === 'off' || !player.loaded) return;
            
            if (!audioContextStarted) {
                // S'assurer que le contexte audio est démarré au premier clic
                Tone.start(); 
                audioContextStarted = true;
                statusMessage.textContent = "Contexte audio démarré.";
                showOverlayBriefly();
            }

            isScratching = true;
            vinylImage.style.cursor = 'grabbing';
            
            // Calculer et stocker l'angle initial
            const center = getVinylCenter();
            lastAngle = getAngle(clientX, clientY, center.x, center.y);
            
            currentRpmDisplay.textContent = 'SCRATCH';
            statusMessage.textContent = (directionFactor > 0) ? "Lecture Manuelle" : "Lecture Manuelle Inv.";
            showOverlayBriefly();
        };

        const moveScratch = (clientX, clientY) => {
            if (!isScratching) return;

            const center = getVinylCenter();
            const currentAngle = getAngle(clientX, clientY, center.x, center.y);
            
            let deltaAngle = currentAngle - lastAngle;

            // Gestion du "wrap-around" (passage de -180° à 180° ou inversement)
            if (deltaAngle > 180) {
                deltaAngle -= 360;
            } else if (deltaAngle < -180) {
                deltaAngle += 360;
            }

            // Mise à jour de la vitesse audio (currentVelocity) basée sur la variation angulaire
            currentVelocity = deltaAngle * ANGULAR_MULTIPLIER;
            
            // Mise à jour de la rotation visuelle instantanée
            rotationDegrees += deltaAngle;
            
            // Stocker l'angle actuel pour la prochaine itération
            lastAngle = currentAngle;
        };

        const endScratch = () => {
            if (!isScratching) return;
            
            isScratching = false;
            currentVelocity = 0; // Remet la vitesse manuelle à zéro pour le decay visuel
            
            vinylImage.style.cursor = 'grab';

            // Afficher l'état du moteur RPM
            currentRpmDisplay.textContent = currentMode === 'off' ? 'STOP' : currentMode + ' tours';
            statusMessage.textContent = currentMode === 'off' ? "Arrêté, prêt à jouer." : (directionFactor > 0) ? "En Lecture" : "Lecture Inversée";
            showOverlayBriefly();
        };
        
        // --- ÉVÉNEMENTS MOUSE ET TOUCH ---
        
        // Événements souris
        vinylImage.addEventListener('mousedown', (e) => startScratch(e.clientX, e.clientY));
        turntableContainer.addEventListener('mousemove', (e) => moveScratch(e.clientX, e.clientY));
        turntableContainer.addEventListener('mouseup', endScratch);
        turntableContainer.addEventListener('mouseleave', endScratch);
        
        // Événements tactiles
        vinylImage.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { 
                startScratch(e.touches[0].clientX, e.touches[0].clientY); 
            }
        });
        turntableContainer.addEventListener('touchmove', (e) => {
            // Empêche le défilement de l'écran pendant le scratch
            e.preventDefault(); 
            if (e.touches.length === 1) { 
                moveScratch(e.touches[0].clientX, e.touches[0].clientY); 
            }
        }, { passive: false }); 
        turntableContainer.addEventListener('touchend', endScratch);
        turntableContainer.addEventListener('touchcancel', endScratch);


        // --- BOUCLE D'ANIMATION VISUELLE ET AUDIO (VSYNC) ---
        
        function animate() {
            requestAnimationFrame(animate);

            if (!player || !player.loaded || bufferDuration === 0) {
                // Application de la rotation visuelle même si l'audio n'est pas prêt
                vinylImage.style.transform = `translate(-50%, -50%) rotate(${rotationDegrees}deg)`;
                return;
            }
            
            const now = performance.now(); 
            // Delta time en secondes
            const dt = (now - lastTime) / 1000; 
            lastTime = now;

            // 1. Déterminer le taux de lecture effectif pour le buffer audio
            let effectiveRate = 0;
            if (isScratching) {
                // Vitesse manuelle (basée sur le mouvement de la main/doigt)
                effectiveRate = currentVelocity * directionFactor;
                // Ajout d'une légère inertie pour ralentir la rotation visuelle à l'arrêt du doigt
                currentVelocity *= 0.95; 
            } else {
                // Vitesse du moteur (RPM * Pitch)
                effectiveRate = targetBaseVelocity * pitchFactor * directionFactor;
                currentVelocity = 0; // S'assurer que la vitesse manuelle est à zéro
            }
            
            // 2. Mettre à jour la position audio (audioTime)
            audioTime += effectiveRate * dt;

            // 3. Implémenter la Boucle (Wrapping)
            
            // Si le temps dépasse la durée, revenir au début (lecture normale)
            while (audioTime >= bufferDuration) {
                audioTime -= bufferDuration;
            }
            // Si le temps devient négatif, revenir à la fin (lecture inversée)
            while (audioTime < 0) {
                audioTime += bufferDuration;
            }

            // 4. Positionner le lecteur audio (Seek)
            if (Math.abs(effectiveRate) > 0.0001) {
                player.seek(audioTime); 
            }
            
            // 5. Mettre à jour la rotation visuelle (pour le mode moteur uniquement)
            if (!isScratching) {
                // Utiliser le taux effectif pour la rotation visuelle
                rotationDegrees += effectiveRate * VISUAL_RPM_MULTIPLIER * dt;
            }
            
            // Appliquer la rotation visuelle
            vinylImage.style.transform = `translate(-50%, -50%) rotate(${rotationDegrees}deg)`;
        }


        // --- INITIALISATION GLOBALE ---

        // RPM Click Handlers 
        rpmChoices.forEach(choice => {
            choice.addEventListener('click', () => {
                const mode = choice.getAttribute('data-mode');
                setRpmMode(mode);
            });
        });
        
        // Chicken Head Click Handler
        rpmImg.addEventListener('click', () => {
            if (currentMode === 'off') {
                setRpmMode('33'); 
            } else {
                setRpmMode(currentMode === '33' ? '45' : '33');
            }
        });

        window.onload = function() {
            loadAudio();
            animate();
            
            // Initialiser l'état visuel du mode scratch/zoom (Zoom Mode par défaut sur Desktop)
            isScratchMode = isMobile() ? false : true; 
            updateScratchModeUI();
        }

    </script>
</body>
</html>
