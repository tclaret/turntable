<!DOCTYPE html>
<html lang="fr">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Platine vinyle ‚Äî S√©lecteur Vintage</title>
<link rel="icon" href="data:,">

<style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
        height:100vh;
        background:#222;
        display:flex;
        flex-direction: column;
        justify-content:center;
        align-items:center;
        font-family: "Helvetica Neue", Arial, sans-serif;
        color:white;
        user-select:none;
        overflow: hidden;
    }

    #turntable-container {
        transition: transform 0.5s ease;
    }

    #turntable {
        position:relative;
        width:80vmin;
        height:80vmin;
        max-width:700px;
        max-height:700px;
        /* Couleur bois sombre */
        background: #634b32; 
        border-radius:12px;
        box-shadow:
            inset 0 0 0 10px rgba(0,0,0,0.2),
            0 20px 50px rgba(0,0,0,0.8);
        overflow:hidden;
    }

    /* Message d'erreur Audio */
    #audio-error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 15px;
        background: #cc0000;
        color: white;
        border-radius: 8px;
        font-weight: bold;
        text-align: center;
        z-index: 100;
        box-shadow: 0 0 20px rgba(0,0,0,0.8);
        display: none; /* Cach√© par d√©faut */
    }

    /* Panneau de contr√¥le g√©n√©ral (Haut-Gauche) */
    .control-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        align-items: center;
        gap: 15px;
        z-index: 50;
        background: rgba(0, 0, 0, 0.4);
        padding: 10px;
        border-radius: 8px;
    }
    
    /* Panneau des fonctionnalit√©s Gemini (Haut-Droit) */
    #gemini-panel {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 50;
        background: rgba(0, 0, 0, 0.4);
        padding: 10px;
        border-radius: 8px;
        align-items: stretch;
    }

    /* Bo√Æte de r√©sultats de l'analyse */
    #analysis-box {
        position: absolute;
        top: 100px; /* Sous le panneau Gemini */
        right: 20px;
        width: 250px;
        max-height: 200px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #00ff00;
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        line-height: 1.4;
        z-index: 50;
        box-shadow: 0 0 15px rgba(0,255,0,0.3);
        display: none;
        overflow-y: auto;
    }

    /* Boutons de style vintage */
    .vintage-btn {
        padding: 8px 16px;
        border: 1px solid #444;
        border-radius: 4px;
        background: linear-gradient(to bottom, #e0e0e0 0%, #b0b0b0 100%);
        color: #333;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        box-shadow: 
            0 3px 5px rgba(0,0,0,0.5),
            inset 0 1px 0 rgba(255,255,255,0.8);
        transition: transform 0.1s, box-shadow 0.1s, background 0.2s;
        text-shadow: 0 1px 0 rgba(255,255,255,0.5);
    }

    .vintage-btn:active {
        transform: translateY(2px);
        box-shadow: 
            0 1px 2px rgba(0,0,0,0.5),
            inset 0 2px 5px rgba(0,0,0,0.2);
        background: linear-gradient(to bottom, #b0b0b0 0%, #999 100%);
    }
    
    /* √âtat actif sp√©cifique du bouton zoom */
    .vintage-btn.zoom-active {
        background: linear-gradient(to bottom, #aaddff 0%, #6699cc 100%);
        box-shadow: inset 0 0 10px #3498db;
    }
    
    /* Bouton pour les fonctions Gemini */
    .gemini-btn {
        background: linear-gradient(to bottom, #77b300 0%, #446600 100%);
        color: white;
        border-color: #335500;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .gemini-btn:active {
        background: linear-gradient(to bottom, #446600 0%, #2a3e00 100%);
    }

    /* Indicateur de chargement pour l'analyse */
    .loading-spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #00ff00;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        margin-right: 10px;
        display: none;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }


    /* --- Contr√¥le de la vitesse (Pitch) (Bas-Droit) --- */
    #pitch-control {
        position: absolute; 
        bottom: 20px;       
        right: 20px;        
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 5px 10px;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.4); 
        border: 1px solid rgba(255, 255, 255, 0.2);
        z-index: 50;
        width: 120px; 
    }

    #pitch-control label {
        font-size: 10px;
        font-weight: bold;
        text-transform: uppercase;
        color: #ddd;
    }
    
    #pitch-slider {
        -webkit-appearance: none;
        width: 100px; 
        height: 8px;
        background: #333;
        outline: none;
        opacity: 0.9;
        -webkit-transition: .2s;
        transition: opacity .2s;
        border-radius: 4px;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.8);
    }

    #pitch-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #f0f0f0;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0,0,0,0.5), inset 0 1px 0 #fff;
    }

    /* --- √âchelle de Pitch --- */
    #pitch-scale {
        position: relative;
        width: 100px; 
        height: 10px;
        margin-top: 2px;
        margin-bottom: 5px;
    }

    .pitch-mark {
        position: absolute;
        bottom: 0;
        transform: translateX(-50%);
        height: 5px;
        width: 1px;
        background: #ccc;
    }

    .pitch-label {
        position: absolute;
        bottom: 5px;
        transform: translateX(-50%);
        font-size: 8px;
        color: #ccc;
        font-weight: normal;
        white-space: nowrap;
    }

    /* Marque longue pour le point z√©ro */
    .pitch-mark.zero {
        height: 8px;
        background: #00ff00; 
    }


    /* --- Disque vinyle --- */
    #vinyl {
        position:absolute;
        top:50%; left:50%;
        transform: translate(-50%, -50%);
        width:85%; height:85%;
        border-radius:50%;
        
        /* URL D'IMAGE CORRIG√âE */
        background-image: url('https://tclaret.github.io/turntable/img/DISC.png');
        background-size: cover;
        background-position: center;

        cursor:grab;
        will-change:transform;
        box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
    #vinyl:active { cursor:grabbing; }

    /* Conteneur RPM (Bas-Gauche) */
    #rpm-wrapper {
        position:absolute;
        bottom: 5%;
        left: 5%;
        width: auto;
        display: flex;
        flex-direction: column; 
        align-items: center;     
        gap: 8px;                
        z-index:45;
        background: rgba(0,0,0,0.2); 
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.1);
    }

    /* 1. √âtiquettes du haut (45 - OFF - 33) */
    .rpm-labels {
        display:flex;
        justify-content:space-between;
        width: 90px; 
        font-size: 10px;
        font-family: sans-serif;
        font-weight: bold;
        color: #d0d0d0;
        text-shadow: 0 1px 2px black;
        pointer-events: none;
    }
    
    .rpm-labels span {
        width: 25px;
        text-align: center;
    }

    /* 2. Contr√¥les de points au milieu */
    #rpm-controls {
        display:flex;
        justify-content:space-between;
        width: 90px; 
        position: relative;
    }

    .rpm-choice {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #444;
        border: 2px solid #222;
        cursor: pointer;
        box-shadow: inset 0 2px 3px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.2);
        transition: background 0.2s;
        margin: 0 auto; 
    }

    .rpm-choice:hover { background: #666; }
    
    /* Lumi√®re LED/Point actif */
    .rpm-choice.active { 
        background: #00ff00; 
        box-shadow: 0 0 10px #00ff00, inset 0 2px 3px rgba(0,0,0,0.5);
        border-color: #003300;
    }

    /* 3. Image du bouton en bas */
    #rpm-img {
        width: 30px; 
        height: auto;
        display: block;
        transform-origin: center center;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        filter: drop-shadow(0 5px 5px rgba(0,0,0,0.7));
    }

</style>
</head>
<body>

<div id="turntable-container">
    <div id="turntable">
        
        <!-- Message d'erreur Audio -->
        <div id="audio-error">ERREUR AUDIO : Fichier JB.mp3 introuvable.</div>

        <!-- Panneau de contr√¥le (Haut-Gauche) -->
        <div class="control-panel">
            <button id="stop-button" class="vintage-btn">Arr√™t</button>
            <button id="zoom-button" class="vintage-btn">Zoom</button>
        </div>
        
        <!-- Panneau des fonctionnalit√©s Gemini (Haut-Droit) -->
        <div id="gemini-panel">
            <button id="analysis-button" class="vintage-btn gemini-btn">
                <div class="loading-spinner" id="analysis-spinner"></div>
                Analyse de Piste ‚ú®
            </button>
            <button id="tts-button" class="vintage-btn gemini-btn">
                Synth√®se Vocale (TTS) ‚ú®
            </button>
        </div>
        
        <!-- Bo√Æte de r√©sultats de l'analyse -->
        <div id="analysis-box">
            <!-- Le contenu sera ins√©r√© ici par JavaScript -->
        </div>

        <!-- Contr√¥le de la vitesse (Pitch) (Bas-Droit) -->
        <div id="pitch-control">
            <label for="pitch-slider">Pitch</label>
            <input type="range" min="-15" max="15" value="0" id="pitch-slider">
            <div id="pitch-scale">
                
                <!-- +15% -->
                <span class="pitch-mark" style="left:0%;"></span>
                <span class="pitch-label" style="left:0%;">+15%</span>

                <!-- +10% -->
                <span class="pitch-mark" style="left:16.67%;"></span>
                <span class="pitch-label" style="left:16.67%;">+10</span>

                <!-- 0% -->
                <span class="pitch-mark zero" style="left:50%;"></span>
                <span class="pitch-label" style="left:50%; top: 1px;">0</span>

                <!-- -10% -->
                <span class="pitch-mark" style="left:83.33%;"></span>
                <span class="pitch-label" style="left:83.33%;">-10</span>

                <!-- -15% -->
                <span class="pitch-mark" style="left:100%;"></span>
                <span class="pitch-label" style="left:100%;">-15%</span>
            </div>
        </div>


        <!-- Le disque vinyle -->
        <div id="vinyl" style="transform: rotate(0deg);">
            <!-- Le disque est rendu par l'image de fond -->
        </div>

        <!-- Contr√¥le RPM (Bas-Gauche) -->
        <div id="rpm-wrapper">
            <!-- 1. √âtiquettes du haut (45 - OFF - 33) -->
            <div class="rpm-labels">
                <span>45</span>
                <span>ARR√äT</span>
                <span>33</span>
            </div>

            <!-- 2. Contr√¥les de points au milieu -->
            <div id="rpm-controls">
                <div class="rpm-choice" data-rpm="45" title="45 RPM"></div>
                <div class="rpm-choice active" data-rpm="off" title="Arr√™t"></div>
                <!-- Cl√© '33' utilis√©e pour la vitesse 33 1/3 RPM -->
                <div class="rpm-choice" data-rpm="33" title="33 1/3 RPM"></div> 
            </div>

            <!-- 3. Image du bouton en bas -->
            <img id="rpm-img" 
                 /* URL D'IMAGE CORRIG√âE */
                 src="https://tclaret.github.io/turntable/img/ChickenHead.png" 
                 alt="Bouton RPM"
                 style="transform: rotate(0deg);">
        </div>
    </div>
</div>

<script>
    const vinyl = document.getElementById("vinyl");
    const rpmImg = document.getElementById("rpm-img");
    const rpmChoices = document.querySelectorAll('.rpm-choice');
    const stopBtn = document.getElementById('stop-button');
    const zoomBtn = document.getElementById('zoom-button');
    const turntableContainer = document.getElementById('turntable-container');
    const pitchSlider = document.getElementById('pitch-slider');
    const audioErrorDiv = document.getElementById('audio-error'); 
    
    // Nouveaux √©l√©ments pour Gemini
    const analysisBtn = document.getElementById('analysis-button');
    const analysisBox = document.getElementById('analysis-box');
    const analysisSpinner = document.getElementById('analysis-spinner');
    const ttsBtn = document.getElementById('tts-button');


    let currentRotation = 0;
    let velocity = 0;
    let targetBaseVelocity = 0; 
    let currentPitchFactor = 1.0; 
    let isDragging = false;
    let lastAngle = 0;
    let center = {x:0, y:0};
    
    // Constantes de physique
    const returnStrength = 0.08; 
    const dragSensitivity = 3.0; 
    const MAX_PLAYBACK_RATE = 2.5; 
    const MAX_SCRATCH_ACCELERATION = 0.5; 

    let isZoomed = false;

    // √âtat Audio
    let audioCuePointSeconds = 0; 
    let isPlaying = false; 
    let audioDurationSeconds = 0; 
    
    let rpmMode = "off";
    // Calcul pr√©cis des degr√©s par frame (pour 60 FPS) :
    const RPM_BASE_SPEED = {"33": 360 / 60 / 60 * (100 / 3), "45": 4.5, "off": 0}; 
    const NORMAL_RPM_VELOCITY = RPM_BASE_SPEED["33"]; 

    // Configuration Audio
    let audioCtx = null;
    let buffer = null;
    let source = null;
    // Piste simul√©e pour l'analyse
    const TRACK_TITLE = "James Brown - Get Up (I Feel Like Being a) Sex Machine";
    // URL AUDIO CORRIG√âE
    const audioURL = "https://tclaret.github.io/turntable/JB.mp3"; 

    // Cl√© API fournie par l'environnement
    const apiKey = ""; 

    function initAudio(){ 
        if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); 
    }
    
    /**
     * Convertit la rotation visuelle (en degr√©s) en un d√©calage audio (en secondes).
     */
    function rotationToAudioOffset(degrees, duration) {
        let offset = (degrees * duration / 360) % duration;
        if (offset < 0) {
            offset += duration;
        }
        return offset;
    }


    /*
     * Fonction ASYNC pour charger l'audio et d√©marrer la lecture.
     */
    async function startPlayback() {
        initAudio();
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
        }

        if(!buffer) {
            try {
                const res = await fetch(audioURL); 
                // V√©rifier si la r√©ponse est un succ√®s HTTP (statut 200-299)
                if(!res.ok) throw new Error("Audio file not found: " + audioURL);
                const arr = await res.arrayBuffer(); 
                buffer = await audioCtx.decodeAudioData(arr); 
                audioDurationSeconds = buffer.duration; 
                audioErrorDiv.style.display = 'none'; 
            } catch(e) {
                console.error("√âchec du chargement ou du d√©codage audio:", e);
                // Mettre √† jour le message d'erreur avec l'URL compl√®te
                audioErrorDiv.innerHTML = `ERREUR AUDIO : Fichier <br> ${audioURL} <br> introuvable.`; 
                audioErrorDiv.style.display = 'block'; 
                return; 
            }
        }
        
        if(source) {
            try { source.stop(); } catch(e){}
        }

        const rpmSpeed = RPM_BASE_SPEED[rpmMode];
        let initialRate = (rpmSpeed / NORMAL_RPM_VELOCITY) * currentPitchFactor; 
        if (rpmMode === 'off' || NORMAL_RPM_VELOCITY === 0) initialRate = 1.0 * currentPitchFactor;
        initialRate = Math.max(0.01, Math.min(MAX_PLAYBACK_RATE, initialRate)); 

        source = audioCtx.createBufferSource(); 
        source.buffer = buffer; 
        source.loop = true; 
        
        source.playbackRate.value = initialRate; 
        source.connect(audioCtx.destination); 
        
        source.start(0, audioCuePointSeconds); 
        isPlaying = true;
    }

    /**
     * Arr√™te l'audio et sauvegarde le point de cue actuel.
     */
    function stopAudio() {
        if(source && audioCtx && buffer) {
            try { 
                audioCuePointSeconds = rotationToAudioOffset(currentRotation, buffer.duration);
                source.stop(); 
            } catch(e){
                console.error("Erreur lors de l'arr√™t de la source audio:", e);
            }
        }
        source = null;
        isPlaying = false;
    }

    // --- Moteur Physique ---
    function updateCenter(){ 
        const r = vinyl.getBoundingClientRect(); 
        center.x = r.left + r.width/2; 
        center.y = r.top + r.height/2; 
    }
    updateCenter(); 
    window.addEventListener("resize", updateCenter);

    /**
     * Calcule l'angle du pointeur par rapport au centre de la platine.
     * L'angle est entre -180 et 180 degr√©s. 0¬∞ = droite, 90¬∞ = haut.
     */
    function getAngle(e){ 
        return Math.atan2(e.clientY - center.y, e.clientX - center.x) * 180 / Math.PI; 
    }

    vinyl.addEventListener("pointerdown", async e => { 
        const angle = getAngle(e);
        
        // Zone de Scratch C√¥t√© Gauche (90¬∞ √† 180¬∞ ET -180¬∞ √† -90¬∞)
        const isInScratchZone = (angle >= 90) || (angle <= -90);

        if (isInScratchZone) {
            // Mode Scratch activ√©
            if(!isPlaying && rpmMode !== 'off') {
                 await startPlayback(); 
            }
            
            isDragging = true; 
            lastAngle = angle; 
            vinyl.setPointerCapture(e.pointerId); 
            vinyl.style.cursor = "grabbing";
        } else {
            // Clic en dehors de la zone de scratch. Le mouvement de la souris n'aura pas d'effet.
            isDragging = false; 
            vinyl.setPointerCapture(e.pointerId); 
            vinyl.style.cursor = "grab";
        }
    });

    vinyl.addEventListener("pointermove", e => { 
        // Le mouvement n'est trait√© que si isDragging est VRAI (d√©fini dans pointerdown)
        if(!isDragging) return; 
        if(!isPlaying) return; 

        const ang = getAngle(e); 
        let delta = ang - lastAngle; 
        if(delta > 180) delta -= 360; 
        if(delta < -180) delta += 360; 
        lastAngle = ang; 
        
        const dragDelta = delta * dragSensitivity; 
        
        // Calculer la diff√©rence de vitesse demand√©e
        const requestedChange = dragDelta - velocity;

        // APPLIQUER LA LIMITE D'ACC√âL√âRATION (Slew Rate Limiter)
        const limitedChange = Math.max(
            -MAX_SCRATCH_ACCELERATION, 
            Math.min(MAX_SCRATCH_ACCELERATION, requestedChange)
        );

        velocity += limitedChange; 
        currentRotation += velocity; 
        targetBaseVelocity = velocity; 
    });

    vinyl.addEventListener("pointerup", () => { 
        isDragging = false; 
        // Revenir √† la vitesse RPM cible, modul√©e par le pitch
        updateTargetVelocity(); 
        vinyl.style.cursor = "grab";
        
        if(rpmMode === 'off') {
            stopAudio(); 
            currentRotation = 0;
            vinyl.style.transform = `translate(-50%, -50%) rotate(0deg)`;
        }
    });
    
    // --- Calcul de la vitesse cible ---
    function updateTargetVelocity() {
        if (!isDragging) {
            targetBaseVelocity = RPM_BASE_SPEED[rpmMode] * currentPitchFactor;
        }
    }

    function engine(){ 
        if(!isDragging){ 
            // Transition progressive (acc√©l√©ration/d√©c√©l√©ration) vers la vitesse cible
            velocity += (targetBaseVelocity - velocity) * returnStrength; 
        } 
        
        currentRotation += velocity; 
        vinyl.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg)`; 
        
        // Mise √† jour de la vitesse de lecture audio (Pitch Shift)
        if(source && audioCtx && isPlaying){ 
            
            let targetRate = (velocity / NORMAL_RPM_VELOCITY) * currentPitchFactor; 
            
            // LIMITER LA VITESSE MAXIMALE DU SON
            const finalRate = Math.max(0.01, Math.min(MAX_PLAYBACK_RATE, targetRate)); 
            
            source.playbackRate.value = finalRate; 
        } 
        
        requestAnimationFrame(engine); 
    }
    engine();

    // --- Logique de Contr√¥le RPM ---
    function setRPM(mode){
        rpmMode = mode;
        updateTargetVelocity(); 

        if (mode !== 'off') {
            const isStartingNew = !isPlaying;

            // D√©marrage de la vitesse l√©g√®rement plus haute que la cible (spin up)
            velocity = targetBaseVelocity * 1.2; 
            
            if (isStartingNew) {
                startPlayback(); 
            } 

        } else {
            // Mode Arr√™t
            velocity = 0; 
            stopAudio(); 
        }

        // Mettre √† jour l'interface utilisateur
        rpmChoices.forEach(c => c.classList.remove('active'));
        document.querySelector(`.rpm-choice[data-rpm='${mode}']`).classList.add('active');
        
        // Rotation du bouton (45 - OFF - 33)
        if(mode === "45") rpmImg.style.transform = "rotate(-30deg)"; 
        else if(mode === "33") rpmImg.style.transform = "rotate(30deg)"; 
        else rpmImg.style.transform = "rotate(0deg)";
    }

    rpmChoices.forEach(c => c.addEventListener('click', () => { setRPM(c.dataset.rpm); }));

    // --- Logique du Slider Pitch ---
    pitchSlider.addEventListener('input', () => {
        const percentageChange = parseFloat(pitchSlider.value) / 100; 
        currentPitchFactor = 1.0 + percentageChange;
        
        updateTargetVelocity(); 
    });


    // --- Logique du Bouton Arr√™t ---
    stopBtn.addEventListener('click', () => {
        setRPM("off"); 
    });

    // --- Logique du Bouton Zoom ---
    zoomBtn.addEventListener('click', () => {
        isZoomed = !isZoomed;
        if(isZoomed) {
            turntableContainer.style.transform = "scale(1.5)";
            zoomBtn.classList.add("zoom-active");
        } else {
            turntableContainer.style.transform = "scale(1)";
            zoomBtn.classList.remove("zoom-active");
        }
        setTimeout(updateCenter, 550);
    });
    
    // Initialisation
    setRPM("off");


    /* * --- GESTION DES APPELS GEMINI --- 
     */

    // Fonction utilitaire pour la gestion des erreurs et la r√©essai (Backoff)
    async function fetchWithRetry(url, options, maxRetries = 5) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response;
            } catch (error) {
                if (i === maxRetries - 1) throw error;
                const delay = Math.pow(2, i) * 1000; // D√©lai exponentiel
                await new Promise(resolve => setTimeout(resolve, delay));
                console.warn(`Tentative √©chou√©e ${i + 1}. Nouvelle tentative dans ${delay / 1000}s...`);
            }
        }
    }


    // --- 1. FONCTION D'ANALYSE DE PISTE (LLM + Grounding) ---
    analysisBtn.addEventListener('click', callGeminiAnalysis);

    async function callGeminiAnalysis() {
        analysisBtn.disabled = true;
        analysisSpinner.style.display = 'block';
        analysisBox.style.display = 'block';
        analysisBox.innerHTML = '<p>Analyse de la piste... üé∂</p>';

        const userQuery = `Fournis une courte anecdote historique et un fait d'importance de la chanson funk "${TRACK_TITLE}" en trois phrases au maximum.`;
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            // Activation de la recherche Google pour obtenir des informations factuelles
            tools: [{ "google_search": {} }],
            systemInstruction: {
                parts: [{ text: "Agis comme un expert en histoire de la musique et en analyse de vinyles. R√©dige ta r√©ponse en fran√ßais et dans un style enthousiaste, sans introduction ni conclusion." }]
            },
        };

        try {
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text || "Impossible d'analyser la piste.";
            
            analysisBox.innerHTML = `<strong>Analyse de ${TRACK_TITLE}:</strong><br>${text}`;

            // Optionnel: Affichage des sources
            const groundingMetadata = result.candidates?.[0]?.groundingMetadata;
            if (groundingMetadata && groundingMetadata.groundingAttributions) {
                analysisBox.innerHTML += `<div style="margin-top: 10px; font-size: 10px; opacity: 0.7;">Sources (recherche Gemini)</div>`;
            }

        } catch (error) {
            console.error("Erreur lors de l'appel Gemini (Analyse):", error);
            analysisBox.innerHTML = '<p style="color:red;">Erreur: Impossible de contacter le serveur d\'analyse.</p>';
        } finally {
            analysisBtn.disabled = false;
            analysisSpinner.style.display = 'none';
        }
    }


    // --- 2. FONCTION DE SYNTH√àSE VOCALE (TTS) ---
    ttsBtn.addEventListener('click', callGeminiTTS);
    
    // Fonction utilitaire pour convertir PCM en WAV
    function pcmToWav(pcm16, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
        const blockAlign = numChannels * (bitsPerSample / 8);
        const dataSize = pcm16.byteLength;
        
        // FIX: Calcul correct de la taille totale du fichier (44 octets d'en-t√™te + taille des donn√©es)
        const totalSize = 44 + dataSize; 
        const riffChunkSize = totalSize - 8; // Taille totale moins 'RIFF' (4) et 'ChunkSize' (4)

        const buffer = new ArrayBuffer(totalSize);
        const view = new DataView(buffer);

        // RIFF chunk
        writeString(view, 0, 'RIFF');
        view.setUint32(4, riffChunkSize, true); 
        writeString(view, 8, 'WAVE');

        // FMT chunk
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true); // Chunk size
        view.setUint16(20, 1, true);  // Compression code (PCM)
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitsPerSample, true);

        // DATA chunk
        writeString(view, 36, 'data');
        view.setUint32(40, dataSize, true);

        // PCM data
        let offset = 44;
        for (let i = 0; i < pcm16.length; i++) {
            // Utiliser setInt16 pour les donn√©es 16-bit sign√©es
            view.setInt16(offset, pcm16[i], true);
            offset += 2;
        }

        return new Blob([buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
    
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    async function callGeminiTTS() {
        ttsBtn.disabled = true;

        const currentRpm = rpmMode === 'off' ? '√† l\'arr√™t' : `${rpmMode} tours par minute`;
        const pitchValue = parseFloat(pitchSlider.value).toFixed(1);
        const pitchText = pitchValue === "0.0" ? "z√©ro pour cent" : `${pitchValue} pour cent`;
        
        const ttsPrompt = `Dites avec une voix de commentateur radio enthousiaste: "Le syst√®me est actuellement r√©gl√© sur ${currentRpm}, avec un ajustement de pitch de ${pitchText}!"`;

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
        
        const payload = {
            contents: [{ parts: [{ text: ttsPrompt }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: "Puck" } // Voix entra√Ænante
                    }
                }
            },
        };

        try {
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                // Extraire le sample rate du mimeType (e.g., audio/L16;rate=24000)
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                const pcmDataBuffer = base64ToArrayBuffer(audioData);
                // L'API retourne du PCM 16-bit sign√© (Int16Array)
                const pcm16 = new Int16Array(pcmDataBuffer); 
                
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);
                
                // Jouer l'audio
                const audio = new Audio(audioUrl);
                audio.play();

            } else {
                console.error("Erreur TTS: Donn√©es audio manquantes ou format incorrect.");
            }
        } catch (error) {
            console.error("Erreur lors de l'appel Gemini (TTS):", error);
        } finally {
            ttsBtn.disabled = false;
        }
    }

</script>
</body>
</html>
