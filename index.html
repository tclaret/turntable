<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Turntable â€” Vintage Selector</title>
<link rel="icon" href="data:,">

<style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
        height:100vh;
        background:#222;
        display:flex;
        justify-content:center;
        align-items:center;
        font-family: "Helvetica Neue", Arial, sans-serif;
        color:white;
        user-select:none;
        overflow: hidden;
    }

    #turntable-container {
        transition: transform 0.5s ease;
    }

    #turntable {
        position:relative;
        width:80vmin;
        height:80vmin;
        max-width:700px;
        max-height:700px;
        /* Updated: Solid dark wood color */
        background: #634b32; 
        border-radius:12px;
        box-shadow:
            inset 0 0 0 10px rgba(0,0,0,0.2),
            0 20px 50px rgba(0,0,0,0.8);
        overflow:hidden;
    }

    /* Metal Plate for buttons (Top-Left) */
    .control-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        align-items: center;
        gap: 15px;
        z-index: 50;
        background: rgba(0, 0, 0, 0.4);
        padding: 10px;
        border-radius: 8px;
    }

    /* Styled Vintage Buttons */
    .vintage-btn {
        padding: 8px 16px;
        border: 1px solid #444;
        border-radius: 4px;
        background: linear-gradient(to bottom, #e0e0e0 0%, #b0b0b0 100%);
        color: #333;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        box-shadow: 
            0 3px 5px rgba(0,0,0,0.5),
            inset 0 1px 0 rgba(255,255,255,0.8);
        transition: transform 0.1s, box-shadow 0.1s, background 0.2s;
        text-shadow: 0 1px 0 rgba(255,255,255,0.5);
    }

    .vintage-btn:active {
        transform: translateY(2px);
        box-shadow: 
            0 1px 2px rgba(0,0,0,0.5),
            inset 0 2px 5px rgba(0,0,0,0.2);
        background: linear-gradient(to bottom, #b0b0b0 0%, #999 100%);
    }
    
    /* Specific button active states for logic indication */
    .vintage-btn.zoom-active {
        background: linear-gradient(to bottom, #aaddff 0%, #6699cc 100%);
        box-shadow: inset 0 0 10px #3498db;
    }

    /* --- Pitch Slider Styling (Bottom-Right) --- */
    #pitch-control {
        position: absolute; 
        bottom: 20px;       
        right: 20px;        
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 5px 10px;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.4); 
        border: 1px solid rgba(255, 255, 255, 0.2);
        z-index: 50;
        width: 120px; /* Increased width to accommodate the scale */
    }

    #pitch-control label {
        font-size: 10px;
        font-weight: bold;
        text-transform: uppercase;
        color: #ddd;
    }
    
    #pitch-slider {
        -webkit-appearance: none;
        width: 100px; /* Adjusted width */
        height: 8px;
        background: #333;
        outline: none;
        opacity: 0.9;
        -webkit-transition: .2s;
        transition: opacity .2s;
        border-radius: 4px;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.8);
    }

    #pitch-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #f0f0f0;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(0,0,0,0.5), inset 0 1px 0 #fff;
    }

    /* --- Pitch Scale Marks --- */
    #pitch-scale {
        position: relative;
        width: 100px; /* Matches slider width */
        height: 10px;
        margin-top: 2px;
        margin-bottom: 5px;
    }

    .pitch-mark {
        position: absolute;
        bottom: 0;
        transform: translateX(-50%);
        height: 5px;
        width: 1px;
        background: #ccc;
    }

    .pitch-label {
        position: absolute;
        bottom: 5px;
        transform: translateX(-50%);
        font-size: 8px;
        color: #ccc;
        font-weight: normal;
        white-space: nowrap;
    }

    /* Long mark for the zero point */
    .pitch-mark.zero {
        height: 8px;
        background: #00ff00; /* Green highlight for zero pitch */
    }


    /* --- Vinyl Restoration using original local path (img/DISC.png) --- */
    #vinyl {
        position:absolute;
        top:50%; left:50%;
        transform: translate(-50%, -50%);
        width:85%; height:85%;
        border-radius:50%;
        
        background-image: url('img/DISC.png');
        background-size: cover;
        background-position: center;

        cursor:grab;
        will-change:transform;
        box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
    #vinyl:active { cursor:grabbing; }

    /* RPM Section Wrapper (Bottom-Left) */
    #rpm-wrapper {
        position:absolute;
        bottom: 5%;
        left: 5%;
        width: auto;
        display: flex;
        flex-direction: column; /* Vertical Stack */
        align-items: center;     /* Center everything horizontally */
        gap: 8px;                /* Space between Labels, Dots, Image */
        z-index:45;
        background: rgba(0,0,0,0.2); 
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.1);
    }

    /* 1. Labels on TOP (No Change) */
    .rpm-labels {
        display:flex;
        justify-content:space-between;
        width: 90px; 
        font-size: 10px;
        font-family: sans-serif;
        font-weight: bold;
        color: #d0d0d0;
        text-shadow: 0 1px 2px black;
        pointer-events: none;
    }
    
    .rpm-labels span {
        width: 25px;
        text-align: center;
    }

    /* 2. Dots in MIDDLE (No Change) */
    #rpm-controls {
        display:flex;
        justify-content:space-between;
        width: 90px; 
        position: relative;
    }

    .rpm-choice {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #444;
        border: 2px solid #222;
        cursor: pointer;
        box-shadow: inset 0 2px 3px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.2);
        transition: background 0.2s;
        margin: 0 auto; 
    }

    .rpm-choice:hover { background: #666; }
    
    /* Light up the LED/Dot when active */
    .rpm-choice.active { 
        background: #00ff00; 
        box-shadow: 0 0 10px #00ff00, inset 0 2px 3px rgba(0,0,0,0.5);
        border-color: #003300;
    }

    /* 3. Image at BOTTOM */
    #rpm-img {
        width: 30px; 
        height: auto;
        display: block;
        transform-origin: center center;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        filter: drop-shadow(0 5px 5px rgba(0,0,0,0.7));
    }

</style>
</head>
<body>

<div id="turntable-container">
    <div id="turntable">
        
        <!-- Control Panel (Top-Left) -->
        <div class="control-panel">
            <button id="stop-button" class="vintage-btn">Stop</button>
            <button id="zoom-button" class="vintage-btn">Zoom</button>
        </div>
        
        <!-- Pitch Control Slider (Bottom-Right) with Scale -->
        <div id="pitch-control">
            <label for="pitch-slider">Pitch</label>
            <input type="range" min="-15" max="15" value="0" id="pitch-slider">
            <div id="pitch-scale">
                <!-- Scale Marks for -15% to +15% range -->
                
                <!-- -15% -->
                <span class="pitch-mark" style="left:0%;"></span>
                <span class="pitch-label" style="left:0%;">+15%</span>

                <!-- -10% -->
                <span class="pitch-mark" style="left:16.67%;"></span>
                <span class="pitch-label" style="left:16.67%;">+10</span>

                <!-- 0% -->
                <span class="pitch-mark zero" style="left:50%;"></span>
                <span class="pitch-label" style="left:50%; top: 1px;">0</span>

                <!-- +10% -->
                <span class="pitch-mark" style="left:83.33%;"></span>
                <span class="pitch-label" style="left:83.33%;">-10</span>

                <!-- +15% -->
                <span class="pitch-mark" style="left:100%;"></span>
                <span class="pitch-label" style="left:100%;">-15%</span>
            </div>
        </div>


        <!-- The vinyl disc uses the local img/DISC.png path -->
        <div id="vinyl" style="transform: rotate(0deg);">
            <!-- Content removed as the background image now represents the disc. -->
        </div>

        <!-- RPM Control (Bottom-Left) -->
        <div id="rpm-wrapper">
            <!-- 1. Labels Top (Inverted: 33 - OFF - 45) -->
            <div class="rpm-labels">
                <span>33</span>
                <span>OFF</span>
                <span>45</span>
            </div>

            <!-- 2. Controls Middle -->
            <div id="rpm-controls">
                <div class="rpm-choice" data-rpm="33" title="33 RPM"></div>
                <div class="rpm-choice active" data-rpm="off" title="Stop"></div>
                <div class="rpm-choice" data-rpm="45" title="45 RPM"></div>
            </div>

            <!-- 3. Image Bottom (Knob now uses the local img/ChickenHead.png path and is 30px wide) -->
            <img id="rpm-img" 
                 src="img/ChickenHead.png" 
                 alt="RPM Knob"
                 style="transform: rotate(0deg);">
        </div>
    </div>
</div>

<script>
    const vinyl = document.getElementById("vinyl");
    const rpmImg = document.getElementById("rpm-img");
    const rpmChoices = document.querySelectorAll('.rpm-choice');
    const stopBtn = document.getElementById('stop-button');
    const zoomBtn = document.getElementById('zoom-button');
    const turntableContainer = document.getElementById('turntable-container');
    const pitchSlider = document.getElementById('pitch-slider');

    let currentRotation = 0;
    let velocity = 0;
    let targetBaseVelocity = 0; // Speed set by 33/45 button
    let currentPitchFactor = 1.0; // Speed modulation from slider
    let isDragging = false;
    let lastAngle = 0;
    let center = {x:0, y:0};
    
    // Physics constants for scratching
    const returnStrength = 0.005; // Low friction/high inertia
    const dragSensitivity = 1.5; // Multiplier for drag input
    const pitchMappingFactor = 0.15; // How rotation velocity affects audio pitch
    let isZoomed = false;

    // Audio Cueing State
    let audioCuePointSeconds = 0; // The audio position (offset) to start/restart from
    let isPlaying = false; // Simple flag to track if audio is active
    let audioDurationSeconds = 0; // Total duration of the audio buffer
    
    // Base speed values (will be multiplied by pitch factor)
    let rpmMode = "off";
    const RPM_BASE_SPEED = {"33":0.6, "45":0.9, "off":0};
    const NORMAL_RPM_VELOCITY = RPM_BASE_SPEED["33"]; // Used as the baseline for rate calculation

    // Audio Setup
    let audioCtx = null;
    let buffer = null;
    let source = null;
    const audioURL = "JB.mp3"; 

    function initAudio(){ 
        if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); 
    }
    
    /**
     * Maps the visual rotation (in degrees) to an audio offset (in seconds).
     * This is the core function for maintaining the cue point across stops/starts.
     * We assume one full 360-degree rotation of the vinyl represents one full loop 
     * of the audio buffer.
     * @param {number} degrees - The total accumulated rotation in degrees.
     * @param {number} duration - The total duration of the audio buffer.
     * @returns {number} The audio time offset in seconds.
     */
    function rotationToAudioOffset(degrees, duration) {
        // We use a constant mapping: 360 degrees = full duration.
        // The rotation is modulo 360 to stay within one loop rotation
        let offset = (degrees * duration / 360) % duration;
        // Handle negative offsets (reverse scratching)
        if (offset < 0) {
            offset += duration;
        }
        return offset;
    }


    /*
     * ASYNC function to load audio and start playback from a specific offset.
     * This is called when transitioning from OFF to 33/45.
     */
    async function startPlayback() {
        initAudio();
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
        }

        if(!buffer) {
            try {
                const res = await fetch(audioURL); 
                if(!res.ok) throw new Error("Audio file not found: " + audioURL);
                const arr = await res.arrayBuffer(); 
                buffer = await audioCtx.decodeAudioData(arr); 
                audioDurationSeconds = buffer.duration; // Store buffer duration
            } catch(e) {
                console.warn("Audio load or decode failed. Ensure JB.mp3 is available:", e);
                return; 
            }
        }
        
        // Stop the existing source before creating a new one
        if(source) {
            try { source.stop(); } catch(e){}
        }

        source = audioCtx.createBufferSource(); 
        source.buffer = buffer; 
        source.loop = true; 
        
        // Initial playback rate is 1.0 (normal speed), modulated by the pitch slider
        source.playbackRate.value = 1.0 * currentPitchFactor; 
        source.connect(audioCtx.destination); 
        
        // Start playback from the current cue point
        source.start(0, audioCuePointSeconds); 
        isPlaying = true;
    }

    /**
     * Stops the audio and saves the current cue point based on visual rotation.
     */
    function stopAudio() {
        if(source && audioCtx && buffer) {
            try { 
                // Calculate the new cue point based on the last visual rotation
                audioCuePointSeconds = rotationToAudioOffset(currentRotation, buffer.duration);
                source.stop(); 
            } catch(e){
                console.error("Error stopping source:", e);
            }
        }
        source = null;
        isPlaying = false;
    }

    // --- Physics Engine ---
    function updateCenter(){ 
        const r = vinyl.getBoundingClientRect(); 
        center.x = r.left + r.width/2; 
        center.y = r.top + r.height/2; 
    }
    updateCenter(); 
    window.addEventListener("resize", updateCenter);

    function getAngle(e){ 
        return Math.atan2(e.clientY - center.y, e.clientX - center.x) * 180 / Math.PI; 
    }

    vinyl.addEventListener("pointerdown", async e => { 
        // Only start audio if not playing and RPM is set to ON (to load the buffer)
        if(!isPlaying && rpmMode !== 'off') {
             await startPlayback(); 
        }
        // If playing, we just start dragging; we don't restart the audio source.
        
        isDragging=true; 
        lastAngle=getAngle(e); 
        vinyl.setPointerCapture(e.pointerId); 
        vinyl.style.cursor = "grabbing";
    });

    vinyl.addEventListener("pointermove", e => { 
        if(!isDragging) return; 
        const ang = getAngle(e); 
        let delta = ang - lastAngle; 
        if(delta > 180) delta -= 360; 
        if(delta < -180) delta += 360; 
        lastAngle = ang; 
        
        const dragDelta = delta * dragSensitivity; 
        
        currentRotation += dragDelta; 
        velocity = dragDelta; 
        // Target velocity is overridden by drag velocity during scratching
        targetBaseVelocity = dragDelta; 
    });

    vinyl.addEventListener("pointerup", () => { 
        isDragging = false; 
        // Revert target velocity to the calculated RPM speed, modulated by pitch
        updateTargetVelocity(); 
        vinyl.style.cursor = "grab";
        
        // If the mode is off, save the cue point and stop the audio after letting go
        if(rpmMode === 'off') {
            stopAudio(); 
            // Reset visual rotation to 0 when stopped for a clean look
            currentRotation = 0;
            vinyl.style.transform = `translate(-50%, -50%) rotate(0deg)`;
        }
    });
    
    // --- Target Velocity Calculation ---
    function updateTargetVelocity() {
        // Only update if not currently scratching
        if (!isDragging) {
             // Target velocity is the RPM base speed multiplied by the pitch factor
            targetBaseVelocity = RPM_BASE_SPEED[rpmMode] * currentPitchFactor;
        }
    }

    function engine(){ 
        if(!isDragging){ 
            // Gradually transition current velocity towards target velocity (spin up/down effect)
            velocity += (targetBaseVelocity - velocity) * returnStrength; 
        } 
        
        currentRotation += velocity; 
        // Apply rotation to the vinyl image element
        vinyl.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg)`; 
        
        // Pitch shift effect: link rotation speed (velocity) to music speed
        if(source && audioCtx && isPlaying){ 
            // 1. Calculate the rate based on the instantaneous velocity relative to base speed
            // This is what gives the scratching/speed-up effect.
            let targetRate = (velocity / NORMAL_RPM_VELOCITY) * currentPitchFactor; 
            
            // 2. Clamp and set the rate
            const finalRate = Math.max(0.01, targetRate);
            source.playbackRate.value = finalRate;
        } 
        
        requestAnimationFrame(engine); 
    }
    engine();

    // --- RPM Control Logic ---
    function setRPM(mode){
        rpmMode = mode;
        updateTargetVelocity(); // Recalculate based on new RPM mode

        if (mode !== 'off') {
            velocity = targetBaseVelocity * 0.4; // Jump to 40% speed immediately
            startPlayback(); // Will restart from saved cue point
        } else {
            velocity = 0; 
            stopAudio(); // Saves cue point and stops audio
        }

        // Update UI
        rpmChoices.forEach(c => c.classList.remove('active'));
        document.querySelector(`.rpm-choice[data-rpm='${mode}']`).classList.add('active');
        
        // Rotate Knob Image 
        if(mode === "33") rpmImg.style.transform = "rotate(-30deg)";
        else if(mode === "45") rpmImg.style.transform = "rotate(30deg)";
        else rpmImg.style.transform = "rotate(0deg)";
    }

    rpmChoices.forEach(c => c.addEventListener('click', () => { setRPM(c.dataset.rpm); }));

    // --- Pitch Slider Logic ---
    pitchSlider.addEventListener('input', () => {
        const percentageChange = parseFloat(pitchSlider.value) / 100; 
        currentPitchFactor = 1.0 + percentageChange;
        
        // If playing, restart the audio to apply the new base pitch immediately
        if (isPlaying) {
             // We don't need to call startPlayback if we simply set the rate to the new pitch factor
             // Since the engine loop modulates the rate based on velocity, and velocity uses targetBaseVelocity,
             // and targetBaseVelocity uses currentPitchFactor, it updates automatically.
             updateTargetVelocity(); 
        } else {
             // If stopped, update target velocity for the next spin-up
             updateTargetVelocity();
        }
    });


    // --- Stop Button Logic ---
    stopBtn.addEventListener('click', () => {
        // setRPM("off") now correctly handles saving the cue point and stopping all motion.
        setRPM("off"); 
    });

    // --- Zoom Button Logic ---
    zoomBtn.addEventListener('click', () => {
        isZoomed = !isZoomed;
        if(isZoomed) {
            turntableContainer.style.transform = "scale(1.5)";
            zoomBtn.classList.add("zoom-active");
        } else {
            turntableContainer.style.transform = "scale(1)";
            zoomBtn.classList.remove("zoom-active");
        }
        setTimeout(updateCenter, 550);
    });
    
    // Initial setup
    setRPM("off");

</script>
</body>
</html>
